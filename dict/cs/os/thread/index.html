<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/ui.css">
    <title>YeolYi</title>
    <link rel="stylesheet" href="/css/googlecode.min.css">
    <script src="/js/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4395679975264140"
    crossorigin="anonymous"></script>
</head>

<body>
    <header>
        <a href="/" id="yeolyi-logo">YeolYi</a>
        <nav>
            <a href="/dev" class="nav__button">Dev</a>
            <a href="/dict" class="nav__button">Dict</a>
            <a href="/stories" class="nav__button">Stories</a>
        </nav>
    </header>
    <section id="container">
        <div id="post-header">
            <h2>쓰레드</h2>
        </div>
        <div id="post-content">
            <p>지금까지는 single thread of control인 프로세스들을 살펴봄. 하지만 multiple threads of control을 가질 수 있다. PC를 잘 바꾸면 같은 프로그램 내에서도 여러 context의 코드를 실행할 수 있다. </p>
<p>A thread is a lightweight process(LWP). A basic unit of CPU utilization. </p>
<ul>
<li>thread ID</li>
<li>program counter</li>
<li>register set</li>
<li>stack</li>
</ul>
<p>으로 구성된다. </p>
<p><img alt="" src="multithreaded.png" /></p>
<h2>Multithreading의 장점</h2>
<p>client-server 시스템에서 여러 request를 함께 처리할 수 있다. </p>
<ul>
<li>Responsiveness: may allow continued execution</li>
<li>Resource Sharing: threads share resources of process(code와 data 영역을 공유함)</li>
<li>Economy: cheaper than process creation</li>
<li>Scalability(확장성): process can take advantage of multiprocessor architectures</li>
</ul>
<p>자바에서 쓰레드는 프로그램 실행의 기본적인 모델이다. 쓰레드 생성과 관리를 위한 많은 기능들이 있음. </p>
<h2>자바에서의 쓰레드 사용</h2>
<p>Inheritance from the Thread class
- 다른 클래스 상속이 안되는 문제. 다른 방법 쓰기</p>
<pre><code>public class MyThread1 extends Thread {
    public void run() {
        try {
            while (true) {
                System.out.println(&quot;Hello, Thread!&quot;);
                Thread.sleep(500);
            }
        } catch (InterruptedException ie) {
            System.out.println(&quot;I'm interuppted&quot;);
        }
    }
}

public class testcode {
    public static final void main(String[] args) {
        MyThread1 thread = new MyThread1();
        thread.start();
        System.out.print(&quot;Hello, My Child!&quot;);
    }
}
</code></pre>
<p>Implementing the Runnable interface
- 제일 많이 씀. </p>
<pre><code>public class MyThread2 implements Runnable {
    public void run() {
        try {
            while (true) {
                System.out.println(&quot;Hello, Runnable!&quot;);
                Thread.sleep(500);
            }
        } catch (InterruptedException ie) {
            System.out.println(&quot;I'm interrupted&quot;);
        }
    }
}

public class testcode {
    public static final void main(String[] args) {
        Thread thread = new Thread(new MyThread2());
        thread.start();
        System.out.print(&quot;Hello, My Runnable Child!&quot;);
    }
}
</code></pre>
<p>Using the Lambda expressing(1.8~)
- 새로운 클래스도 귀찮고, 람다로 구현</p>
<pre><code>public class testcode {
    public static final void main(String[] args) {
        Runnable task = () -&gt; {
            try {
                while (true) {
                    System.out.println(&quot;Hello, Lambda Runnable!&quot;);
                    Thread.sleep(500);
                }
            } catch (InterruptedException ie) {
                System.out.println(&quot;I'm interrupted&quot;);
            }
        };
        Thread thread = new Thread(task);
        thread.start();
        System.out.println(&quot;Hello, My Lambda Child!&quot;);
    }
}
</code></pre>
<p>부모 쓰레드의 대기: Join</p>
<pre><code>public class testcode {
    public static final void main(String[] args) {
        Runnable task = () -&gt; {
            for (int i = 0; i &lt; 5; i++) {
                System.out.println(&quot;Hello, Lambda Runnable!&quot;);
            }
        };
        Thread thread = new Thread(task);
        thread.start();
        try {
            thread.join();
        } catch (InterruptedException ie) {
            System.out.println(&quot;Parent thread is interrupted&quot;);
        }
        System.out.println(&quot;Hello, My Joined Child!&quot;);
    }
}
</code></pre>
<p>쓰레드의 종료: interrupt</p>
<pre><code>public class testcode {
    public static final void main(String[] args) throws InterruptedException {
        Runnable task = () -&gt; {
            try {
                while (true) {
                    System.out.println(&quot;Hello, Lambda Runnable!&quot;);
                    Thread.sleep(100);
                }
            } catch (InterruptedException ie) {
                System.out.println(&quot;I'm interupted&quot;);
            }
        };
        Thread thread = new Thread(task);
        thread.start();
        Thread.sleep(500);
        thread.interrupt();
        System.out.println(&quot;Hello, My Interrupted Child!&quot;);
    }
}
</code></pre>
<p>프로그램은 짤 줄은 몰라도 6, 7장 동기화 부분에서 자바로 설명하니까 코드는 얼추 알아두기~</p>
<h2>멀티코어 시스템에서의 멀티쓰레딩</h2>
<p>More efficient use of multiple cores for improved concurrency</p>
<p>싱글코어에서는 사이사이 interleaved되겠지만, 멀티코어에서는 몇몇 쓰레드들은 parallel하게 작동할 수 있다. </p>
<p>Programming Challenge</p>
<ul>
<li>Identifying tasks: 여러 문제로 나눌 수 있는 부분이 어디인가?</li>
<li>Balance: 각 task가 같은 양의 일을 할 수 있도록</li>
<li>Data splitting</li>
<li>Data dependency</li>
<li>Testing and debugging</li>
</ul>
<h2>암달의 법칙</h2>
<p><img alt="" src="amdahl.png" /></p>
<hr />
<h2>멀티쓰레딩 모델</h2>
<p>user thread / kernel thread</p>
<p>이 둘의 관계</p>
<ul>
<li>Many-to-One Model. 가장 기본적. 유저 쓰레드가 많아지면 감당 못함. </li>
<li>One_to_One Model. </li>
<li>Many-to-Many Model</li>
</ul>
<p>쓰레드 라이브러리는 쓰레드를 만들고 관리하는 API이다. </p>
<blockquote>
<p>An application programming interface (API) is a connection between computers or between computer programs. It is a type of software interface, offering a service to other pieces of software.</p>
<p>The interface to a software library is one type of API. The API describes and prescribes the "expected behavior" (a specification) while the library is an "actual implementation" of this set of rules.</p>
<p>In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information.</p>
</blockquote>
<p>POSIX Pthreads, Windows thread, Java thread(얘네는 운영체제꺼 끌어다? 씀)</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

// data shared by the threads
int sum;
// thread call this function
void *runner(void *param);

int main(int argc, char *argv[])
{
    pthread_t tid;       // thread identifier
    pthread_attr_t attr; // thread attributes;

    pthread_attr_init(&amp;attr);
    pthread_create(&amp;tid, &amp;attr, runner, argv[1]);
    pthread_join(tid, NULL);

    printf(&quot;sum = %d\n&quot;, sum);
}

void *runner(void *param)
{
    int upper = atoi(param);
    sum = 0;
    for (int i = 1; i &lt;= upper; i++)
        sum += i;
    pthread_exit(0);
}
</code></pre>
<p><em>-pthread 옵션 안줘도 작동하긴 함</em></p>
<p>main thread는 기본으로 있는듯!</p>
<h2>The Strategy of Implicit Threading</h2>
<p>알아서 쓰레딩 해줘~</p>
<p>The design of concurrent and parallel applications</p>
<ul>
<li>i.e. the design of multithreading in multicore systems, </li>
<li>is too difficult for application developers.</li>
</ul>
<p>So, transfer the difficulty to compiler and run-time libraries.</p>
<p>네가지 접근법</p>
<ul>
<li>Thread Pools: 쓰레드 유저가 안만들고 Thread Pool에서 잘 가져다 쓰게. getThread</li>
<li>Fork &amp; Join: 책~!</li>
<li>OpenMP: 컴파일러 지시문, API로 C/C++에서 </li>
<li>Grand Central Dispatch(GCD): 애플에서 사용</li>
</ul>
<p>OpenMP: parallel region만 지정해주면 코드블럭을 알아서 parallel하게 실행해줌. 지금까지와는 달리 라이브러리가 아닌 컴파일러에게 지시. </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;

#define SIZE 100000000

int a[SIZE], b[SIZE], c[SIZE]

int main()
{
    for (i = 0; i &lt; SIZE; i++) 
    {
        a[i] = b[i] = i;
    }
    #pragma omp parallel for
    for (i = 0; i &lt; SIZE; i++)
    {
        c[i] = a[i] + b[i];
    }
    return 0;
}
</code></pre>
<p><em>이건 테스트는 못해봄. macOS에 기본적으로 안깔려져있음</em></p>
<p>여러번 실행됨! 병렬이라서. 
omp_set_num_threads(4);, omp_get_thread_num? 도 사용할 수 있음. 
time 써서 시간 측정해보면 병렬처리를 위한 대기 등때문에 user가 긺. </p>
<p>1 2 (2, 3) 2 3 4 2 3</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

void runner()
{
    printf(&quot;Hello I'm thread\n&quot;);
    pthread_exit(0);
}

int main()
{
    pthread_t tid;       // thread identifier
    pthread_attr_t attr; // thread attributes;
    pthread_t tid2;      // thread identifier

    pthread_attr_init(&amp;attr);
    pthread_create(&amp;tid, &amp;attr, runner, NULL);
    pthread_create(&amp;tid2, &amp;attr, runner, NULL);
    fork();
    pthread_join(tid, NULL);
    pthread_join(tid2, NULL);
}
</code></pre>
<p><em>쓰레드도 같이 복사되는듯!</em></p>
<p><img alt="" src="problem.png" /></p>
<p>사실 start() 호출되었다고 바로 실행되는 구조가 아니다. 일단 먼저 '실행대기' 상태에 들어가게 되며 자신의 차례가 오면 실행되는 구조이다. 물론 실행대기 중인 쓰레드가 하나도 없다면
바로 실행 상태로 넘어간다.
참고: 쓰레드의 실행순서는 OS의 스케줄러가 작성한 스케줄에 의해 결정된다.</p>
<p>이거때문인가??</p>
            <script src="https://utteranc.es/client.js" repo="yeolyi/blog" issue-term="pathname" theme="github-light"
                crossorigin="anonymous" async></script>
        </div>
    </section>
</body>

</html>